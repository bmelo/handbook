# -*- coding: utf-8 -*-
#
# pythonguide documentation build configuration file, created by
# sphinx-quickstart on Wed Aug  4 22:51:11 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import datetime
import os
import sys
from pathlib import Path
import json
import dataladhandbook_support

# pull out author list from all-contributors spec
authors = [
    c['name'] for c in json.load(
        (Path(__file__).parent.parent / '.all-contributorsrc').open()).get(
            'contributors', [])
]

# autorunrecord setup (extension used to run and capture the output of
# examples)
autorunrecord_basedir = '/home/me'
# pre-crafted artificial environment to run the code examples in
autorunrecord_env = {
    # make everything talk in english
    'LANG': 'en_US.UTF-8',
    'LANGUAGE': 'en_US:en',
    'LC_CTYPE': 'en_US.UTF-8',
    # use very common shell
    'SHELL': '/bin/bash',
    # keep username extra short to save on line length
    'USER': 'me',
    'USERNAME': 'me',
    'HOME': autorunrecord_basedir,
    # earned a PhD in 1678 and taught mathematics at the University of Padua
    'GIT_AUTHOR_EMAIL': 'elena@example.net',
    'GIT_AUTHOR_NAME': 'Elena Piscopia',
    'HOST': 'padua',
    # maintain the PATH to keep all installed software functional
    'PATH': os.environ['PATH'],
    'GIT_EDITOR': 'vim',
}
if 'CAST_DIR' in os.environ:
    autorunrecord_env['CAST_DIR'] = os.environ['CAST_DIR']
if 'VIRTUAL_ENV' in os.environ:
    # inherit venv, if there is any
    autorunrecord_env.update(VIRTUAL_ENV=os.environ['VIRTUAL_ENV'])


# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath('_themes'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.ifconfig',
    'sphinx.ext.todo',
    'sphinx.ext.intersphinx',
    'sphinx.ext.doctest',
    'sphinxcontrib.autorunrecord',
    'sphinxcontrib.rsvgconverter',
    'sphinxcontrib.plantuml',
    'dataladhandbook_support',
    'sphinxcontrib.bibtex',
]

# configuration to use the bibtex extension: https://sphinxcontrib-bibtex.readthedocs.io/en/latest/usage.html
bibtex_bibfiles = ['refs.bib']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
current_year = datetime.datetime.now().year
project = u'datalad-handbook'
# copyright = (u'2019-{} CC-BY-SA').format(current_year)
copyright = (u'{} CC-BY-SA').format(current_year)

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = dataladhandbook_support.__version__
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = [
    '_build',
    '_themes/*.rst',  # Excluded due to README.rst in _themes/
]

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'tango'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

#manpages_url = 'http://docs.datalad.org/generated/man/{page}.html'

# numbered figures for better referencing
numfig = True
numfig_secnum_depth = 1

# convert quotes and dashes into to proper symbols
smartquotes = True

# Trim spaces before footnote references that are necessary for the reST parser
# to recognize the footnote, but do not look too nice in the output.
trim_footnote_reference_space = True

# -- Options for HTML output ---------------------------------------------------
html_baseurl = 'https://brainhack-princeton.github.io/handbook//'

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'alabaster'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
# more options: https://alabaster.readthedocs.io/en/latest/customization.html
html_theme_options = {
    'show_powered_by': False,
    'github_user': 'brainhack-princeton',
    'github_repo': 'handbook',
    'github_banner': True,
    'show_related': True,
    # colors
    # "DataLad gray"
    'body_text': '#333',
    # this is a lighter variant of the "DataLad yellow"
    'note_bg': '#e2eacdff',
    # the real "DataLad dark gray"
    'note_border': '#333333ff',
    'fixed_sidebar': True,
    'show_relbar_bottom': True,
}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
html_title = 'The Princeton Handbook for Reproducible Neuroimaging'

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    'index':    ['sidebarintro.html', 'sourcelink.html', 'searchbox.html', 'hacks.html', 'extra_space.html'],
    '**':       ['sidebarlogo.html', 'localtoc.html', 'relations.html',
                 'sourcelink.html', 'searchbox.html', 'hacks.html']
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = False

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
html_show_sphinx = False

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'dataladhandbookdoc'

# https://www.sphinx-doc.org/en/master/usage/configuration.html#confval-html_favicon
html_favicon = 'tigerBrain_favicon.png'


# -- Options for LaTeX output --------------------------------------------------

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  (
      'index',
      'dataladhandbook.tex',
      u'The DataLad Handbook',
      u' \\and '.join(a.replace(' ', '~') for a in authors),
      'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
latex_logo = None

latex_toplevel_sectioning = 'part'
latex_show_pagerefs = True
latex_show_urls = 'footnote'
latex_elements = {
    'papersize': 'a4',
    'pointsize': '11pt',
    'figure_align': 'tbp',
    'preamble': r"""
\usepackage{charter}
\usepackage[defaultsans]{lato}
\usepackage{inconsolata}
\setcounter{tocdepth}{0}
""",
}

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'princetonhandbook', u'The Princeton Handbook for Reproducible Neuroimaging',
     [u'all'], 1)
]


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'princetonhandbook'
epub_author = u'all'
epub_publisher = u'all'
epub_copyright = u'2019–{}, all'.format(current_year)

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files that should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
epub_exclude_files = [
    ('search.html', 'Search'),
]

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

todo_include_todos = True

intersphinx_mapping = {
    'python': ('https://docs.python.org/3', None),
}

plantuml_output_format = 'svg'
plantuml_latex_output_format = 'pdf'


def setup(app):
    app.add_stylesheet('custom.css')
    app.add_config_value('internal', '', 'env')


## lots of code to format the references in APA style: https://git.naeka.fr/naeka-org/pybtex-apa-style/-/blob/master/apastyle.py
import re

from pybtex.style.formatting import BaseStyle, toplevel
from pybtex.style.template import (
    field, first_of, href, join, names, optional, optional_field, sentence,
    tag, together, words, node, FieldIsMissing
)

from pybtex.richtext import Text, Symbol


def format_pages(text):
    dash_re = re.compile(r'-+')
    pages = Text(Symbol('ndash')).join(text.split(dash_re))
    if re.search('[-‒–—―]', str(text)):
        return Text("pp.", Symbol('nbsp'), pages)
    return Text("p.", Symbol('nbsp'), pages)


pages = field('pages', apply_func=format_pages)
date = words[field('year'), optional[", ", field('month')]]


@node
def apa_names(children, context, role, **kwargs):
    """Return formatted names as an APA compliant reference list citation."""
    assert not children

    try:
        persons = context['entry'].persons[role]
    except KeyError:
        raise FieldIsMissing(role, context['entry'])

    style = context['style']

    if len(persons) > 7:
        persons = persons[:6] + persons[-1:]
        formatted_names = [style.format_name(
            person, style.abbreviate_names) for person in persons]
        return join(sep=', ', last_sep=', … ')[
            formatted_names].format_data(context)
    else:
        formatted_names = [style.format_name(
            person, style.abbreviate_names) for person in persons]
        return join(sep=', ', sep2=', & ', last_sep=', & ')[
            formatted_names].format_data(context)


class APAStyle(BaseStyle):
    name = 'apa'
    default_name_style = 'lastfirst'
    default_sorting_style = 'author_year_title'
    default_label_style = 'alpha'

    def __init__(self, *args, **kwargs):
        super(APAStyle, self).__init__(*args, **kwargs)
        self.abbreviate_names = True

    def format_names(self, role, as_sentence=True):
        formatted_names = apa_names(role)
        if as_sentence:
            return sentence(capfirst=False)[formatted_names]
        else:
            return formatted_names

    def format_author_or_editor_and_date(self, e):
        if 'author' in e.persons and 'editor' in e.persons:
            return sentence(sep=' ')[
                self.format_names('author'), together["(", date, ")."],
                self.format_editor(e, as_sentence=False)]
        elif 'author' in e.persons:
            return sentence(sep=' ')[
                self.format_names('author'), together["(", date, ")"]]
        else:
            return sentence(sep=' ')[
                self.format_editor(e, as_sentence=False),
                together["(", date, ")"]]

    def format_editor(self, e, as_sentence=True):
        editors = self.format_names('editor', as_sentence=False)
        if 'editor' not in e.persons:
            # when parsing the template, a FieldIsMissing exception
            # will be thrown anyway; no need to do anything now,
            # just return the template that will throw the exception
            return editors
        if len(e.persons['editor']) > 1:
            word = '(Eds.)'
        else:
            word = '(Ed.)'
        result = join(sep=' ')[editors, word]
        if as_sentence:
            return sentence[result]
        else:
            return result

    def format_volume(self, e, for_article=False):
        prefix = "Vol."
        if for_article:
            return optional[
                tag('em')[field('volume')],
                optional['(', field('number'), ')'],
            ]
        else:
            return optional[together[prefix, field('volume')]]

    def format_title(self, e, which_field, as_sentence=True):
        formatted_title = field(
            which_field, apply_func=lambda text: text.capitalize()
        )
        if as_sentence:
            return sentence[formatted_title]
        else:
            return formatted_title

    def format_btitle(self, e, which_field, as_sentence=True):
        formatted_title = tag('em')[field(which_field)]
        if as_sentence:
            return sentence[formatted_title]
        else:
            return formatted_title

    def format_web_refs(self, e):
        # Based on urlbst output.web.refs
        return sentence[
            optional[self.format_url(e)],
            optional[self.format_eprint(e)],
            optional[self.format_pubmed(e)],
            optional[self.format_doi(e)],
        ]

    def format_url(self, e):
        # Based on urlbst format.url
        return words[
            'URL:',
            href[
                field('url', raw=True),
                field('url', raw=True)
            ]
        ]

    def format_pubmed(self, e):
        # Based on urlbst format.pubmed
        return href[
            join[
                'https://www.ncbi.nlm.nih.gov/pubmed/',
                field('pubmed', raw=True)
            ],
            join[
                'PMID:',
                field('pubmed', raw=True)
            ]
        ]

    def format_doi(self, e):
        # Based on urlbst format.doi
        return href[
            join[
                'https://doi.org/',
                field('doi', raw=True)
            ],
            join[
                'doi:',
                field('doi', raw=True)
            ]
        ]

    def format_eprint(self, e):
        # Based on urlbst format.eprint
        return href[
            join[
                'https://arxiv.org/abs/',
                field('eprint', raw=True)
            ],
            join[
                'arXiv:',
                field('eprint', raw=True)
            ]
        ]

    def get_article_template(self, e):
        # Required fields: author, title, journal, year
        # Optional fields: volume, number, pages, month, note, key
        volume_and_pages = first_of[
            # volume and pages, with optional issue number
            optional[
                join[
                    self.format_volume(e, for_article=True),
                    optional[', ', pages]
                ],
            ],
            # pages only
            pages,
        ]
        template = toplevel[
            self.format_names('author'),
            join["(", date, ")"],
            self.format_title(e, 'title'),
            words[
                tag('em')[field('journal')],
                optional["(", volume_and_pages, ")"],
            ],
            self.format_web_refs(e),
        ]
        return template

    def get_book_template(self, e):
        # Required fields: author/editor, title, publisher, year
        # Optional fields: volume, series, address, edition, month, note, key,
        #                  isbn
        return toplevel[
            self.format_author_or_editor_and_date(e),
            join(sep=' ')[
                self.format_btitle(e, 'title'),
                optional[
                    sentence[
                        optional_field('edition'),
                        self.format_volume(e),
                    ]
                ]
            ],
            join(sep=': ')[
                optional_field('address'),
                field('publisher'),
            ]
        ]

    def get_booklet_template(self, e):
        # Required fields: title
        # Optional fields: author, howpublished, address, month, year, note,
        #                  key
        return toplevel[
            optional[self.format_names('author')],
            join["(", first_of[optional[date], "n.d."], ")"],
            self.format_btitle(e, 'title'),
            optional_field('address'),
        ]

    def get_inbook_template(self, e):
        # Required fields: author/editor, title, chapter/pages, publisher, year
        # Optional fields: volume, series, address, edition, month, note, key
        return toplevel[
            self.format_author_or_editor_and_date(e),
            sentence(sep=' ')[
                self.format_btitle(e, 'title', as_sentence=False),
                optional[
                    join[
                        "(",
                        sentence(add_period=False)[
                            optional_field('edition'),
                            self.format_volume(e),
                            pages,
                        ],
                        ")"
                    ]
                ]
            ],
            sentence(sep=': ')[
                optional_field('address'),
                field('publisher'),
            ]
        ]

    def get_incollection_template(self, e):
        # Required fields: author, title, booktitle, year
        # Optional fields: editor, pages, organization, publisher, address,
        #                  month, note, key
        return toplevel[
            self.format_author_or_editor_and_date(e),
            self.format_title(e, 'title'),
            sentence(sep=' ')[
                self.format_btitle(e, 'booktitle'),
                optional["(", pages, ")"]
            ],
            sentence(sep=': ')[
                optional_field('address'),
                field('publisher'),
            ]
        ]

    def get_inproceedings_template(self, e):
        # Required fields: author, title, booktitle, year
        # Optional fields: editor, pages, organization, publisher, address,
        #                  month, note, key
        return toplevel[
            self.format_author_or_editor_and_date(e),
            self.format_title(e, 'title'),
            sentence(sep=' ')[
                self.format_btitle(e, 'booktitle'),
                optional["(", pages, ")"]
            ],
            sentence(sep=': ')[
                optional_field('address'),
                field('publisher'),
            ],
            self.format_web_refs(e)
        ]

    def get_manual_template(self, e):
        # Required fields: title
        # Optional fields: author, organization, address, edition, month, year,
        #                  note, key
        return toplevel[
            join[
                first_of[
                    optional[self.format_names('author')],
                    optional[field('organization')],
                    "None to claim their bones"
                ], " (", date, ")"
            ],
            self.format_btitle(e, 'title'),
            optional_field('address'),
            self.format_web_refs(e)
        ]

    def get_mastersthesis_template(self, e):
        # Required fields: author, title, school, year
        # Optional fields: address, month, note, key
        return toplevel[
            join[self.format_names('author'), " (", date, ")"],
            words[
                self.format_btitle(e, 'title'),
                "(Master's thesis)"
            ],
            sentence[
                field('school'),
                optional_field('address'),
            ],
        ]

    def get_misc_template(self, e):
        # Required fields: aucun
        # Optional fields: author, title, howpublished, month, year, note, key,
        #                  type
        template = toplevel[
            optional[self.format_names('author')],
            optional[date],
            optional[self.format_btitle(e, 'title')],
        ]
        return template

    def get_phdthesis_template(self, e):
        # Required fields: author, title, school, year
        # Optional fields: address, month, note, key
        return toplevel[
            words[self.format_names('author'), join["(", date, ")"]],
            words[
                self.format_btitle(e, 'title'),
                "(Doctoral dissertation)"
            ],
            sentence[
                field('school'),
                optional_field('address'),
            ],
        ]

    def get_proceedings_template(self, e):
        # Required fields: title, year
        # Optional fields: editor, publisher, organization, address, month, note, key
        if 'editor' in e.persons:
            return toplevel[
                words[
                    self.format_editor(e, as_sentence=False),
                    join["(", date, ")"]
                ],
                self.format_btitle(e, 'title', as_sentence=False)
            ]
        else:
            return toplevel[
                words[
                    optional_field('organization'),
                    join["(", date, ")"]
                ],
                self.format_btitle(e, 'title', as_sentence=False),
            ]

    def get_techreport_template(self, e):
        # Required fields: author, title, institution, year
        # Optional fields: type, number, address, month, note, key
        return toplevel[
            words[self.format_names('author'), join["(", date, ")"]],
            self.format_btitle(e, 'title'),
            field('institution')
        ]

    def get_unpublished_template(self, e):
        # Required fields: author, title, note
        # Optional fields: month, year, key
        template = toplevel[
            words[
                self.format_names('author'),
                optional[date]
            ],
            self.format_btitle(e, 'title'),
            field('note')
        ]
        return template

